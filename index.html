<!DOCTYPE html>
<html lang="en">
  <head>
    <title>SDF Physics</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

    <link
      rel="stylesheet"
      type="text/css"
      href="./css/styles.css"
      media="screen"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Slab"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="container"></div>
    <div id="info">
      <h1>SDF Physics</h1>
      <p>A stream of GPGPU particles bouncing against SDF volumes.</p>
      <p>
        Move the mouse around and the stream and light source will target the
        red point. Click and drag to rotate the camera, right-click and drag to
        pan.
      </p>
      <p>Play with the parameters to change how the stream behaves.</p>
      <p>
        Source:
        <a href="https://github.com/spite/sdf-physics">GitHub</a>
        | More stuff
        <a href="https://twitter.com/thespite">Twitter</a>
      </p>
    </div>

    <script src="./js/three.min.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/Maf.js"></script>
    <script src="./js/THREE.PingPongTexture.js"></script>
    <script src="./js/THREE.ShaderTexture.js"></script>
    <script src="./js/THREE.FBOHelper.js"></script>
    <script src="./js/Bloom.js"></script>
    <script src="./js/dat.gui.min.js"></script>

    <script type="x-shader/x-vertex" id="ortho-vs">
      precision highp float;

      attribute vec3 position;
      attribute vec2 uv;

      varying vec2 vUv;

      void main() {

      	vUv = uv;
      	gl_Position = vec4( position, 1. );

      }
    </script>

    <script type="x-shader/x-vertex" id="light-vs">
      precision highp float;

      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      varying vec2 vUv;

      void main() {
      	vUv = uv;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );
      }
    </script>

    <script type="x-shader/x-vertex" id="position-fs">
      precision highp float;

      uniform sampler2D source;
      uniform sampler2D velocities;
      uniform sampler2D original;

      uniform float reset;
      uniform vec3 spawnSource;
      uniform float spread;

      varying vec2 vUv;

      void main() {

      	if( reset == 1. ) {
      		vec4 original = texture2D( original, vUv );
      		gl_FragColor = vec4(original.xyz,1.);
      	} else {
      		vec4 v = texture2D( velocities, vUv );
      		vec4 p = texture2D( source, vUv );
      		if( v.a == 100. ) {
      			vec4 original = texture2D( original, vUv );
      			p.xyz = spawnSource + spread * original.xyz;
      		}
      		gl_FragColor = p;
      		gl_FragColor.xyz += v.xyz;
      	}

      }
    </script>

    <script type="x-shader/x-vertex" id="velocity-fs">
      precision highp float;

      uniform sampler2D source;
      uniform sampler2D positions;
      uniform sampler2D particles;
      uniform sampler2D original;

      uniform vec4 spherePositions[10];
      uniform vec4 cubePositions[10];
      uniform vec4 cubeQuaternions[10];
      uniform vec4 torusQuaternions[10];
      uniform vec4 torusPositions[10];

      uniform int numSpheres;
      uniform int numCubes;
      uniform int numTori;

      uniform float reset;
      uniform vec3 spawnVelocity;
      uniform vec3 wind;
      uniform float scatter;
      uniform float friction;

      varying vec2 vUv;

      const float PI = 3.14159265359;

      float hash( float n ) { // 0 - 1
          return fract(sin(n)*3538.5453);
      }

      vec3 randomSphereDir(vec2 rnd) {
      	float s = rnd.x*PI*2.;
      	float t = rnd.y*2.-1.;
      	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
      }

      vec3 randomHemisphereDir(vec3 dir, float i) {
      	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
      	return v * sign(dot(v, dir));
      }

      float sdSphere( vec3 p, float s ){
      	return length(p)-s;
      }

      float sdBox( vec3 p, vec3 b ) {
        vec3 d = abs(p) - b;
        return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
      }

      float sdTorus( vec3 p, vec2 t ) {
        vec2 q = vec2(length(p.xz)-t.x,p.y);
        return length(q)-t.y;
      }

      vec3 rotateVector( vec4 quat, vec3 vec ){
      	return vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );
      }

      vec3 calcBoxNormal(vec3 p, vec4 q, vec3 b, float e) {
        const vec3 v1 = vec3( 1.0,-1.0,-1.0);
        const vec3 v2 = vec3(-1.0,-1.0, 1.0);
        const vec3 v3 = vec3(-1.0, 1.0,-1.0);
        const vec3 v4 = vec3( 1.0, 1.0, 1.0);

        return normalize( v1 * sdBox( rotateVector( q, p + v1 * e ), b ) +
                          v2 * sdBox( rotateVector( q, p + v2 * e ), b ) +
                          v3 * sdBox( rotateVector( q, p + v3 * e ), b ) +
                          v4 * sdBox( rotateVector( q, p + v4 * e ), b ) );
      }

      vec3 calcTorusNormal(vec3 p, vec4 q, vec2 b, float e) {
        const vec3 v1 = vec3( 1.0,-1.0,-1.0);
        const vec3 v2 = vec3(-1.0,-1.0, 1.0);
        const vec3 v3 = vec3(-1.0, 1.0,-1.0);
        const vec3 v4 = vec3( 1.0, 1.0, 1.0);

        return normalize( v1 * sdTorus( rotateVector( q, p + v1 * e ), b ) +
                          v2 * sdTorus( rotateVector( q, p + v2 * e ), b ) +
                          v3 * sdTorus( rotateVector( q, p + v3 * e ), b ) +
                          v4 * sdTorus( rotateVector( q, p + v4 * e ), b ) );
      }

      float rand(vec2 co){
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      const float EPSILON = .1;

      vec3 bounce( vec3 v, vec3 n ) {
      	vec3 r = reflect(v,n);
      	n = r;
      	n = mix(r, randomHemisphereDir(r,length(v)),scatter);//vec3( .5 - rand( vUv + v.xz ), .5 - rand( vUv + v.yz ),.5 - rand( vUv + v.zy ) );
      	n = normalize(n);
      	float l = length(v.xyz) * ( 1. - friction );
      	return n * l;
      }

      void main() {

      	vec4 i = texture2D( particles, vUv );
      	vec4 v = texture2D( source, vUv );
      	vec4 p = texture2D( positions, vUv );

      	vec4 q;

      	for( int i = 0; i < 10; i++ ) {
      		if( i >= numSpheres ) continue;
      		vec3 pp = spherePositions[i].xyz - ( p.xyz + v.xyz );
      		float d = sdSphere( pp.xyz, spherePositions[i].w );
      		if( d <= EPSILON ) {
      			v.xyz = bounce(v.xyz,normalize(-pp.xyz));
      			continue;
      		}
      	}

      	for( int i = 0; i < 10; i++ ) {
      		if( i >= numCubes ) continue;
      		q = cubeQuaternions[i];
      		vec3 b = vec3(.5 * cubePositions[i].w);
      		vec3 pp = cubePositions[i].xyz - ( p.xyz + v.xyz );
      		float d = sdBox( rotateVector( q, pp ), b);
      		if( d <= EPSILON ) {
      			vec3 n = -calcBoxNormal( pp, q, b, EPSILON );
      			v.xyz = bounce(v.xyz,n);
      			continue;
      		}
      	}

      	for( int i = 0; i < 10; i++ ) {
      		if( i >= numTori ) continue;
      		q = torusQuaternions[i];
      		vec3 pp = torusPositions[i].xyz - ( p.xyz + v.xyz );
      		vec2 b = vec2(10.,2.)*torusPositions[i].w;
      		float d = sdTorus( rotateVector( q, pp ), b);
      		if( d <= EPSILON ) {
      			vec3 n = -calcTorusNormal( pp, q, b, EPSILON );
      			v.xyz = bounce( v.xyz, n );
      			continue;
      		}
      	}

      	vec3 disturbance = vec3(.5-hash(v.x+v.a),.5-hash(v.y+vUv.x),.5-hash(v.z+vUv.y));
      	disturbance = normalize(disturbance);
      	v.xyz += .01 * disturbance;

      	//v.xyz += wind;

      	v.a -= .1;
      	if( v.a <= 0. ) {
      		v.xyz = spawnVelocity;
      		v.a = 100.;
      	} else {
      		v.y -= .0098 * i.w;
      	}

      	if( reset == 1. ) {
      		vec4 o = texture2D(original,vUv);
      		v = vec4(0.,0.,0.,o.w);
      	}

      	gl_FragColor = v;

      }
    </script>

    <script id="particle-vs" type="x-shader/x-vertex">
      precision highp float;

      attribute vec3 position;
      attribute vec3 offset;
      attribute vec2 uv;

      uniform mat4 modelMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      uniform sampler2D positions;
      uniform sampler2D particles;
      uniform sampler2D velocities;

      uniform vec2 resolution;
      uniform mat4 shadowV;
      uniform mat4 shadowP;
      uniform vec3 lightPosition;

      uniform float size;

      varying vec2 vUv;
      varying vec4 vShadowCoord;

      vec2 rotate(vec2 v, float a) {
      	float s = sin(a);
      	float c = cos(a);
      	mat2 m = mat2(c, -s, s, c);
      	return m * v;
      }

      const mat4 biasMatrix = mat4(
      	0.5, 0.0, 0.0, 0.0,
      	0.0, 0.5, 0.0, 0.0,
      	0.0, 0.0, 0.5, 0.0,
      	0.5, 0.5, 0.5, 1.0
      );

      const float PI = 3.14159265359;

      void main(){

      	vUv = uv;

      	vec4 i = texture2D( particles, offset.xy );
      	vec4 p = texture2D( positions, offset.xy );
      	vec4 v = texture2D( velocities, offset.xy );
      	vec4 pp = p - v;

      	vec4 tlp = projectionMatrix * modelViewMatrix * vec4( p.xyz, 1. );
      	vec4 tlpp = projectionMatrix * modelViewMatrix * vec4( pp.xyz, 1. );
      	float l = max(1.,length(tlp.xy - tlpp.xy));
      	vec2 tlp2 = tlp.xy/tlp.w;
      	vec2 tlpp2 = tlpp.xy/tlpp.w;
      	vec2 dir = normalize(tlp2 - tlpp2);
      	float aspect = resolution.x / resolution.y;
      	dir.x *= aspect;
      	vec2 perp = normalize(vec2(-dir.y,dir.x));
      	if( l == 1. ) {
      		dir = vec2(0.,1.);
      		perp = vec2( 1.,0.);
      	}
      	dir *= l;
      	perp /= l;

      	vec4 mVP = modelViewMatrix * vec4(p.xyz,1.);
      	//mVP.xy += ( dir.xy * position.x + perp.xy * position.y ) * size * i.w;
      	mVP.xy += ( dir.xy * position.x + perp.xy * position.y ) * size * i.w;

      	vShadowCoord = biasMatrix * shadowP * shadowV * modelMatrix * vec4(p.xyz,1.);

      	gl_Position = projectionMatrix * mVP;

      }
    </script>

    <script id="particle-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform float shadow;
      uniform sampler2D depthTexture;
      uniform float shadowMapSize;

      varying vec2 vUv;
      varying vec4 vShadowCoord;

      float decode_float( vec4 value ) {
      	const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
      	return(dot(value, bitSh));
      }

      float random(vec3 seed, int i){
      	vec4 seed4 = vec4(seed,i);
      	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
      	return fract(sin(dot_product) * 43758.5453);
      }

      float sampleVisibility( vec3 coord, float bias ) {
      	//float depth = texture2D( depthTexture, coord.xy ).x;
      	float depth = decode_float(texture2D( depthTexture, coord.xy ));
      	float visibility  = ( coord.z - depth > bias ) ? 0. : 1.;
      	return visibility;
      }

      void main() {

      	/*if( shadow == 1. ) {
      		vec2 barycenter = vec2( .5, .5 );
      		float d = length( vUv.xy - barycenter );
      		d = smoothstep(.45,.49,d);
      		gl_FragColor = vec4( vec3( gl_FragCoord.z ), 1.-d );
      		return;
      	}*/

      	const int NUM_TAPS = 12;

      	vec2 poissonDisk[16];
      	poissonDisk[0 ] = vec2( -0.94201624, -0.39906216 );
      	poissonDisk[1 ] = vec2( 0.94558609, -0.76890725 );
      	poissonDisk[2 ] = vec2( -0.094184101, -0.92938870 );
      	poissonDisk[3 ] = vec2( 0.34495938, 0.29387760 );
      	poissonDisk[4 ] = vec2( -0.91588581, 0.45771432 );
      	poissonDisk[5 ] = vec2( -0.81544232, -0.87912464 );
      	poissonDisk[6 ] = vec2( -0.38277543, 0.27676845 );
      	poissonDisk[7 ] = vec2( 0.97484398, 0.75648379 );
      	poissonDisk[8 ] = vec2( 0.44323325, -0.97511554 );
      	poissonDisk[9 ] = vec2( 0.53742981, -0.47373420 );
      	poissonDisk[10] = vec2( -0.26496911, -0.41893023 );
      	poissonDisk[11] = vec2( 0.79197514, 0.19090188 );
      	poissonDisk[12] = vec2( -0.24188840, 0.99706507 );
      	poissonDisk[13] = vec2( -0.81409955, 0.91437590 );
      	poissonDisk[14] = vec2( 0.19984126, 0.78641367 );
      	poissonDisk[15] = vec2( 0.14383161, -0.14100790 );

      	float occlusion = 0.;
      	vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;
      	if (vShadowCoord.x>=0. && vShadowCoord.x<1.&&vShadowCoord.y>=0. && vShadowCoord.y<1.){
      		for (int i=0; i < NUM_TAPS; i++) {
      			vec2 r = vec2(random(gl_FragCoord.xyz,1), random(gl_FragCoord.zxy,1)) / shadowMapSize;
      			occlusion += sampleVisibility( shadowCoord + vec3(poissonDisk[i] / shadowMapSize + r, 0. ), .002 );
      		}
      		occlusion /= float( NUM_TAPS );
      	}

      	vec2 barycenter = vec2( .5, .5 );
      	float d = length( vUv.xy - barycenter );
      	d = smoothstep(.4,.5,d);
      	gl_FragColor = vec4( vec3( 1.1 ),1.-d);
      	gl_FragColor.a *= .1;
      	gl_FragColor.a *= ( .1 + .9 * occlusion);

      }
    </script>

    <script id="meshes-vs" type="x-shader/x-vertex">
      precision highp float;

      attribute vec3 position;
      attribute vec3 normal;
      attribute vec2 uv;

      uniform mat4 modelMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform mat3 normalMatrix;

      uniform vec2 resolution;
      uniform mat4 shadowV;
      uniform mat4 shadowP;
      uniform vec3 lightPosition;
      uniform vec3 lightDir;

      varying vec4 vShadowCoord;
      varying float vBias;
      varying vec3 vNormal;
      varying float vDiffuse;
      varying vec2 vUv;
      varying vec3 vViewPosition;

      const mat4 biasMatrix = mat4(
      	0.5, 0.0, 0.0, 0.0,
      	0.0, 0.5, 0.0, 0.0,
      	0.0, 0.0, 0.5, 0.0,
      	0.5, 0.5, 0.5, 1.0
      );

      const float PI = 3.14159265359;

      void main(){

      	vec4 mVP = modelViewMatrix * vec4( position, 1.);
      	vViewPosition = mVP.xyz;
      	vShadowCoord = biasMatrix * shadowP * shadowV * modelMatrix * vec4(position.xyz,1.);
      	vUv = uv;
      	vNormal = normalMatrix * normal;

      	vec4 worldPosition = ( modelMatrix * vec4( position, 1. ) );
      	vec3 nWorld = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
      	vec3 L = normalize(lightDir);
      	vec3 n = normalize(nWorld);
      	vDiffuse = clamp( dot( n, L ), 0., 1. );
          float bias = 0.005 * tan( acos( vDiffuse ) );
          bias = clamp( bias, 0., 0.01 );
      	vBias = bias;

      	gl_Position = projectionMatrix * mVP;

      }
    </script>

    <script id="meshes-fs" type="x-shader/x-fragment">
      #extension GL_OES_standard_derivatives : enable

      precision highp float;

      uniform float shadow;
      uniform sampler2D depthTexture;
      uniform vec3 lightDir;
      uniform float shadowMapSize;

      varying vec2 vUv;
      varying vec4 vShadowCoord;
      varying float vDiffuse;
      varying float vBias;
      varying vec3 vNormal;
      varying vec3 vViewPosition;

      #define PI 3.1415926535897932384626433832795

      float shift_right (float v, float amt) {
          v = floor(v) + 0.5;
          return floor(v / exp2(amt));
      }

      float shift_left (float v, float amt) {
          return floor(v * exp2(amt) + 0.5);
      }

      float mask_last (float v, float bits) {
          return mod(v, shift_left(1.0, bits));
      }

      float extract_bits (float num, float from, float to) {
          from = floor(from + 0.5); to = floor(to + 0.5);
          return mask_last(shift_right(num, from), to - from);
      }

      vec4 encode_float (float value) {
      	const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
      	const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
      	vec4 res = fract(value * bitSh);
      	res -= res.xxyz * bitMsk;
      	return res;
      }

      float decode_float( vec4 value ) {
      	const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
      	return(dot(value, bitSh));
      }

      float random(vec3 seed, int i){
      	vec4 seed4 = vec4(seed,i);
      	float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
      	return fract(sin(dot_product) * 43758.5453);
      }

      float sampleVisibility( vec3 coord, float bias ) {
      	float depth = decode_float(texture2D( depthTexture, coord.xy ));
      //	float depth = texture2D( depthTexture, coord.xy ).x;
      	float visibility  = ( coord.z - depth > bias ) ? 0. : 1.;
      	return visibility;
      }

      float stripe( float y ) {
      	return smoothstep( .45, .55, .5 + .5 * sin( 3.1 * ( y + .5 ) * 2. * PI ) );
      }

      vec2 pattern( vec2 p ) {

      	float e = .0001;

      	float prev = stripe( p.x + e );
      	float cur = stripe( p.x );

      	return vec2( cur, prev - cur );

      }

      vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

      	vec3 vSigmaX = dFdx( surf_pos );
      	vec3 vSigmaY = dFdy( surf_pos );
      	vec3 vN = surf_norm;

      	vec3 R1 = cross( vSigmaY, vN );
      	vec3 R2 = cross( vN, vSigmaX );

      	float fDet = dot( vSigmaX, R1 );

      	vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
      	return normalize( abs( fDet ) * surf_norm - vGrad );

      }

      void main() {

      	if( shadow == 1. ) {
      		//gl_FragColor = vec4(gl_FragCoord.z);
      		gl_FragColor = encode_float( gl_FragCoord.z );
      		return;
      	}

      	const int NUM_TAPS = 12;

      	vec2 poissonDisk[16];
      	poissonDisk[0 ] = vec2( -0.94201624, -0.39906216 );
      	poissonDisk[1 ] = vec2( 0.94558609, -0.76890725 );
      	poissonDisk[2 ] = vec2( -0.094184101, -0.92938870 );
      	poissonDisk[3 ] = vec2( 0.34495938, 0.29387760 );
      	poissonDisk[4 ] = vec2( -0.91588581, 0.45771432 );
      	poissonDisk[5 ] = vec2( -0.81544232, -0.87912464 );
      	poissonDisk[6 ] = vec2( -0.38277543, 0.27676845 );
      	poissonDisk[7 ] = vec2( 0.97484398, 0.75648379 );
      	poissonDisk[8 ] = vec2( 0.44323325, -0.97511554 );
      	poissonDisk[9 ] = vec2( 0.53742981, -0.47373420 );
      	poissonDisk[10] = vec2( -0.26496911, -0.41893023 );
      	poissonDisk[11] = vec2( 0.79197514, 0.19090188 );
      	poissonDisk[12] = vec2( -0.24188840, 0.99706507 );
      	poissonDisk[13] = vec2( -0.81409955, 0.91437590 );
      	poissonDisk[14] = vec2( 0.19984126, 0.78641367 );
      	poissonDisk[15] = vec2( 0.14383161, -0.14100790 );

      	float occlusion = 0.;
      	vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;

      	if (vShadowCoord.x>=0. && vShadowCoord.x<1.&&vShadowCoord.y>=0. && vShadowCoord.y<1.){
      		for (int i=0; i < NUM_TAPS; i++) {
      			vec2 r = vec2(random(gl_FragCoord.xyz,1), random(gl_FragCoord.zxy,1)) / shadowMapSize;
      			occlusion += sampleVisibility( shadowCoord + vec3(poissonDisk[i] / shadowMapSize + r, 0. ), .005 );
      		}
      		occlusion /= float( NUM_TAPS );
      		occlusion = clamp(occlusion,0.,1.);
      	}

      	vec2 p = pattern(vUv);
      	vec3 n = normalize(vNormal);
      	vec3 color = mix(vec3(1.),vec3(.9), smoothstep( .45, .55, p.x) );
      	n = perturbNormalArb(-vViewPosition,n, vec2(0.,p.y));

      	vec3 E = normalize(-vViewPosition.xyz);
      	vec3 R = normalize(-reflect(lightDir,n));
      	float specular = 1. * pow(max(dot(R,E),0.0),100.);
      	specular *= occlusion * vDiffuse;
      	float rim = 1. - smoothstep( 0., .5, max( 0., abs( dot( n, normalize( -vViewPosition.xyz ) ) ) ) );
      	rim = .5 * rim;

      	gl_FragColor = vec4( vec3( (.2 + .8* (mix(1.*vDiffuse,1.,rim) * occlusion)) *(mix(color,vec3(1.5),vec3(specular)))),1.);
      }
    </script>

    <script id="light-fs" type="x-shader/x-fragment">
      precision highp float;

      void main() {
      	gl_FragColor = vec4( 2. );
      }
    </script>

    <script id="highlight-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform sampler2D source;
      uniform float threshold;

      varying vec2 vUv;

      void main() {
      	vec4 c = texture2D( source, vUv );
      	c.xyz -= 1.;
      	gl_FragColor = vec4( c );
      }
    </script>

    <script id="blur-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform vec2 resolution;
      uniform sampler2D source;
      uniform vec2 delta;

      varying vec2 vUv;

      vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color;
      }

      vec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
      }

      vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
      }

      void main() {
      	vec4 b  = blur5( source, vUv, resolution, delta );
      	gl_FragColor = b;
      }
    </script>

    <script id="bloom-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform sampler2D base;
      uniform sampler2D level0;
      uniform sampler2D level1;
      uniform sampler2D level2;
      uniform sampler2D level3;
      uniform sampler2D level4;
      uniform sampler2D dirt;

      uniform vec2 resolution;
      uniform float boost;
      uniform float reduction;
      uniform float levels;

      varying vec2 vUv;

      void main() {
      	vec2 res = 1. / resolution;
      	vec2 uv = vUv;

      	vec4 bloom = vec4(0.);
      	if( levels > 0. ) bloom += texture2D( level0, vUv );
      	if( levels > 1. ) bloom += texture2D( level1, vUv );
      	if( levels > 2. ) bloom += texture2D( level2, vUv );
      	if( levels > 3. ) bloom += texture2D( level3, vUv );
      	if( levels > 4. ) bloom += texture2D( level4, vUv );

      	vec4 color = texture2D( base, vUv );
      	vec4 dirt = texture2D( dirt, vUv );
      	gl_FragColor = color + bloom + dirt * 2. * bloom;
      }
    </script>

    <script id="fxaa-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform sampler2D inputTexture;

      uniform vec2 resolution;

      varying vec2 vUv;

      #define FXAA_SPAN_MAX 8.0
      #define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)
      #define FXAA_REDUCE_MIN   (1.0/128.0)
      #define FXAA_SUBPIX_SHIFT (1.0/4.0)
      vec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {
          vec3 rgbNW = texture2D(tex, uv.zw ).xyz;
          vec3 rgbNE = texture2D(tex, uv.zw + vec2(1,0)*rcpFrame.xy ).xyz;
          vec3 rgbSW = texture2D(tex, uv.zw + vec2(0,1)*rcpFrame.xy ).xyz;
          vec3 rgbSE = texture2D(tex, uv.zw + vec2(1,1)*rcpFrame.xy ).xyz;
          vec3 rgbM  = texture2D(tex, uv.xy ).xyz;
          vec3 luma = vec3(0.299, 0.587, 0.114);
          float lumaNW = dot(rgbNW, luma);
          float lumaNE = dot(rgbNE, luma);
          float lumaSW = dot(rgbSW, luma);
          float lumaSE = dot(rgbSE, luma);
          float lumaM  = dot(rgbM,  luma);
          float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
          float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
          vec2 dir;
          dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
          dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
          float dirReduce = max(
              (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
              FXAA_REDUCE_MIN);
          float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
          dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
                max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                dir * rcpDirMin)) * rcpFrame.xy;
          vec3 rgbA = (1.0/2.0) * (
              texture2D(tex, uv.xy + dir * (1.0/3.0 - 0.5) ).xyz +
              texture2D(tex, uv.xy + dir * (2.0/3.0 - 0.5) ).xyz);
          vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
              texture2D(tex, uv.xy + dir * (0.0/3.0 - 0.5) ).xyz +
              texture2D(tex, uv.xy + dir * (3.0/3.0 - 0.5) ).xyz);
          float lumaB = dot(rgbB, luma);
          if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;
          return rgbB;
      }

      void main() {
      	vec2 res = 1. / resolution;
      	vec2 uv = vUv;
      	vec4 aauv = vec4( uv, uv - (res * (0.5 + FXAA_SUBPIX_SHIFT)));
      	vec4 color = vec4(FxaaPixelShader( aauv, inputTexture, res ),1.);
      	gl_FragColor = color;
      }
    </script>

    <script type="x-shader/x-fragment" id="final-fs">
      precision highp float;

      uniform sampler2D inputTexture;
      uniform vec2 resolution;

      uniform float boost;
      uniform float reduction;

      uniform float amount;
      uniform float time;

      varying vec2 vUv;

      float random(vec2 n, float offset ){
      	return .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);
      }

      vec3 gammaCorrect(vec3 color, float gamma){
          return pow(color, vec3(1.0/gamma));
      }

      vec3 levelRange(vec3 color, float minInput, float maxInput){
          return min(max(color - vec3(minInput), vec3(0.0)) / (vec3(maxInput) - vec3(minInput)), vec3(1.0));
      }

      vec3 finalLevels(vec3 color, float minInput, float gamma, float maxInput){
          return gammaCorrect(levelRange(color, minInput, maxInput), gamma);
      }

      float applySoftLightToChannel( float base, float blend ) {
      	return ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)));
      }

      vec3 applySoftLight( vec3 base, vec3 blend ) {
      	return vec3(
      	    applySoftLightToChannel(base.r, blend.r),
      	    applySoftLightToChannel(base.g, blend.g),
      	    applySoftLightToChannel(base.b, blend.b)
      	);
      }

      void main() {

          vec2 res = 2. / resolution;

          vec4 g = texture2D(inputTexture,vUv);
          vec4 r = texture2D(inputTexture,vUv-vec2(res.x,0.));
          vec4 b = texture2D(inputTexture,vUv+vec2(res.x,0.));

          vec4 color = vec4(r.r, g.g, b.b, 1. );
      	color += vec4( vec3( amount * random( vUv, time ) ), 1. );

          vec2 position = vUv - .5;
      	float vignette = length( position );
          vignette = boost - vignette * reduction;

          color.rgb *= vignette;
          color.rgb = finalLevels(color.rgb, 17./255.0, 1.22, 225.0/255.0);

          //color.rgb = .5 * applySoftLight( color.rgb, vec3(0.,76.,250.)/255.)+.5*color.rgb;

          gl_FragColor = color;

      }
    </script>

    <script>
      "use strict";

      var container, renderer, camera, controls, scene;
      var mesh;

      var helper;

      var container = document.getElementById("container");

      var positionSim, velocitySim;
      var objects = { spheres: [], cubes: [], tori: [], all: [] };

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var plane;

      var shadowCamera,
        shadowBuffer,
        shadowMapSize = 512;
      var floatType = THREE.FloatType; //isMobile.any?THREE.HalfFloatType:THREE.FloatType;
      var objMaterial;
      var lightDummy;
      var pointerDummy;
      var baseFBO,
        finalTexture,
        resolution = new THREE.Vector2();
      var fxaaTexture;
      var bloom;

      function initScene() {
        baseFBO = new THREE.WebGLRenderTarget(1, 1, {
          wrapS: THREE.ClampToEdgeWrapping,
          wrapT: THREE.ClampToEdgeWrapping,
          format: THREE.RGBAFormat,
          type: floatType,
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          stencilBuffer: false,
          depthBuffer: true,
        });

        baseFBO.generateMipMaps = false;
        baseFBO.flipY = true;

        helper.attach(baseFBO, "base");

        var s = 100;
        shadowCamera = new THREE.OrthographicCamera(-s, s, s, -s, 10, 300);
        shadowCamera.position.set(100, 100, 100);
        shadowCamera.lookAt(scene.position);

        var lightMaterial = new THREE.RawShaderMaterial({
          uniforms: {},
          vertexShader: document.getElementById("light-vs").textContent,
          fragmentShader: document.getElementById("light-fs").textContent,
          side: THREE.FrontSide,
        });

        lightDummy = new THREE.Mesh(
          new THREE.BoxBufferGeometry(s * 2, s * 2, 1),
          lightMaterial
        );
        scene.add(lightDummy);

        pointerDummy = new THREE.Mesh(
          new THREE.IcosahedronBufferGeometry(0.5, 3),
          new THREE.MeshBasicMaterial({ color: 0xb70000 })
        );
        scene.add(pointerDummy);

        shadowBuffer = new THREE.WebGLRenderTarget(
          shadowMapSize,
          shadowMapSize,
          {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            format: THREE.RGBAFormat,
            type: THREE.UnsignedByteType,
            minFilter: THREE.LinearMipMapLinearFilter,
            magFilter: THREE.LinearFilter,
            stencilBuffer: false,
            depthBuffer: true,
          }
        );

        helper.attach(shadowBuffer, "shadow");
        shadowBuffer.flipY = true;

        var width = 512;
        var height = 512;

        var r = 100;
        var info = new Float32Array(width * height * 4);
        for (var j = 0; j < info.length; j += 4) {
          info[j + 0] = 0;
          info[j + 1] = 0;
          info[j + 2] = 0;
          info[j + 3] = Maf.randomInRange(1, 3);
        }
        var particleInfo = new THREE.DataTexture(
          info,
          width,
          height,
          THREE.RGBAFormat,
          THREE.FloatType
        );
        particleInfo.needsUpdate = true;

        var original = new Float32Array(width * height * 4);
        for (var j = 0; j < original.length; j += 4) {
          var rr;
          var a = Maf.randomInRange(0, 2 * Math.PI);
          var u = Maf.randomInRange(0, 2);
          if (u > 1) rr = 2 - u;
          else rr = u;
          rr *= r;
          original[j + 0] = rr * Math.cos(a);
          original[j + 1] = Maf.randomInRange(150, 160);
          original[j + 2] = rr * Math.sin(a);
          original[j + 3] = Maf.randomInRange(0, 100);
        }
        var particleOriginal = new THREE.DataTexture(
          original,
          width,
          height,
          THREE.RGBAFormat,
          THREE.FloatType
        );
        particleOriginal.needsUpdate = true;

        var instances = width * height;

        var positions = [];
        var offsets = [];

        var r = 100;
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            offsets.push(x / width, y / height, 0);
          }
        }

        var geometry = new THREE.InstancedBufferGeometry();
        geometry.maxInstancedCount = instances;

        var planeGeometry = new THREE.BufferGeometry().fromGeometry(
          new THREE.PlaneGeometry(0.5, 0.5)
        );

        geometry.addAttribute(
          "position",
          new THREE.Float32BufferAttribute(
            planeGeometry.attributes.position.array,
            3
          )
        );
        geometry.addAttribute(
          "uv",
          new THREE.Float32BufferAttribute(planeGeometry.attributes.uv.array, 2)
        );
        geometry.addAttribute(
          "offset",
          new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3)
        );

        var material = new THREE.RawShaderMaterial({
          uniforms: {
            size: { value: 1 },
            positions: { value: null },
            velocities: { value: null },
            resolution: { value: new THREE.Vector2() },
            particles: { value: particleInfo },
            lightPosition: { type: "v3", value: shadowCamera.position },
            depthTexture: { value: null },
            shadowV: { value: new THREE.Matrix4() },
            shadowP: { value: new THREE.Matrix4() },
            shadow: { value: 1 },
            shadowMapSize: { value: shadowMapSize },
          },
          vertexShader: document.getElementById("particle-vs").textContent,
          fragmentShader: document.getElementById("particle-fs").textContent,
          side: THREE.DoubleSide,
          transparent: true,
          wireframe: !true,
          //depthTest: false,
          depthWrite: false,
        });

        mesh = new THREE.Mesh(geometry, material);
        mesh.frustumCulled = false;
        scene.add(mesh);

        var positionShader = new THREE.RawShaderMaterial({
          uniforms: {
            source: { value: null },
            velocities: { value: null },
            original: { value: particleOriginal },
            spawnSource: { value: new THREE.Vector3() },
            spread: { value: 0.1 },
            reset: { value: 1 },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("position-fs").textContent,
        });

        positionSim = new PingPongTexture(
          renderer,
          positionShader,
          width,
          height,
          THREE.RGBAFormat,
          THREE.FloatType
        );

        var NUM_SPHERES = 10;
        var NUM_CUBES = 10;
        var NUM_TORI = 10;

        var r = 100;

        var spherePositions = [];
        for (var j = 0; j < 10; j++) {
          spherePositions.push(
            new THREE.Vector4(
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(10, 20)
            )
          );
        }

        var cubeQuaternions = [];
        var cubePositions = [];
        for (var j = 0; j < 10; j++) {
          cubeQuaternions.push(
            new THREE.Vector4(
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1)
            ).normalize()
          );
          cubePositions.push(
            new THREE.Vector4(
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(20, 30)
            )
          );
        }

        var torusQuaternions = [];
        var torusPositions = [];
        for (var j = 0; j < 10; j++) {
          torusQuaternions.push(
            new THREE.Vector4(
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1),
              Maf.randomInRange(-1, 1)
            ).normalize()
          );
          torusPositions.push(
            new THREE.Vector4(
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(-r, r),
              Maf.randomInRange(1, 3)
            )
          );
        }

        var velocityShader = new THREE.RawShaderMaterial({
          uniforms: {
            source: { value: null },
            positions: { value: null },
            original: { value: particleOriginal },
            spherePositions: { value: spherePositions },
            cubePositions: { value: cubePositions },
            cubeQuaternions: { value: cubeQuaternions },
            torusPositions: { value: torusPositions },
            torusQuaternions: { value: torusQuaternions },
            particles: { value: particleInfo },
            numCubes: { value: NUM_CUBES },
            numSpheres: { value: NUM_SPHERES },
            numTori: { value: NUM_TORI },
            wind: { value: new THREE.Vector3() },
            spawnVelocity: { value: new THREE.Vector3() },
            scatter: { value: 1 },
            friction: { value: 0.7 },
            reset: { value: 1 },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("velocity-fs").textContent,
        });

        velocitySim = new PingPongTexture(
          renderer,
          velocityShader,
          width,
          height,
          THREE.RGBAFormat,
          THREE.FloatType
        );

        helper.attach(positionSim.front, "pos front");
        helper.attach(positionSim.back, "pos back");
        helper.attach(velocitySim.front, "vel front");
        helper.attach(velocitySim.back, "vel back");

        objMaterial = new THREE.RawShaderMaterial({
          uniforms: {
            depthTexture: { value: null },
            shadowV: { value: new THREE.Matrix4() },
            shadowP: { value: new THREE.Matrix4() },
            shadow: { value: 1 },
            lightPosition: { value: shadowCamera.position },
            lightDir: { value: new THREE.Vector3() },
            shadowMapSize: { value: shadowMapSize },
          },
          vertexShader: document.getElementById("meshes-vs").textContent,
          fragmentShader: document.getElementById("meshes-fs").textContent,
          wireframe: !true,
        });

        for (var j = 0; j < NUM_CUBES; j++) {
          var cube = new THREE.Mesh(
            new THREE.BoxBufferGeometry(1, 1, 1),
            objMaterial
          );
          cube.scale.set(
            cubePositions[j].w,
            cubePositions[j].w,
            cubePositions[j].w
          );
          cube.quaternion.copy(cubeQuaternions[j]);
          cube.position.set(
            cubePositions[j].x,
            cubePositions[j].y,
            cubePositions[j].z
          );
          scene.add(cube);
          objects.all.push(cube);
        }

        var sphereGeo = new THREE.IcosahedronBufferGeometry(1, 3);
        for (var j = 0; j < sphereGeo.attributes.uv.array.length; j += 2) {
          var t = sphereGeo.attributes.uv.array[j];
          sphereGeo.attributes.uv.array[j] =
            sphereGeo.attributes.uv.array[j + 1] * 3;
          sphereGeo.attributes.uv.array[j + 1] = t;
        }
        for (var j = 0; j < NUM_SPHERES; j++) {
          var sphere = new THREE.Mesh(sphereGeo, objMaterial);
          sphere.scale.set(
            spherePositions[j].w,
            spherePositions[j].w,
            spherePositions[j].w
          );
          sphere.position.set(
            spherePositions[j].x,
            spherePositions[j].y,
            spherePositions[j].z
          );
          sphere.rotation.set(
            Maf.randomInRange(0, 2 * Math.PI),
            Maf.randomInRange(0, 2 * Math.PI),
            Maf.randomInRange(0, 2 * Math.PI)
          );
          scene.add(sphere);
          objects.all.push(sphere);
        }

        var torusGeo = new THREE.TorusBufferGeometry(10, 2, 16, 50);
        for (var j = 0; j < torusGeo.attributes.uv.array.length; j += 2) {
          torusGeo.attributes.uv.array[j] *= 8;
        }
        var rot = new THREE.Matrix4();
        rot.makeRotationX(Math.PI / 2);
        torusGeo.applyMatrix(rot);

        for (var j = 0; j < NUM_TORI; j++) {
          var torus = new THREE.Mesh(torusGeo, objMaterial);
          torus.scale.set(
            torusPositions[j].w,
            torusPositions[j].w,
            torusPositions[j].w
          );
          torus.position.set(
            torusPositions[j].x,
            torusPositions[j].y,
            torusPositions[j].z
          );
          torus.quaternion.copy(torusQuaternions[j]);
          scene.add(torus);
          objects.tori.push(torus);
          objects.all.push(torus);
        }

        plane = new THREE.Mesh(
          new THREE.PlaneGeometry(10000, 10000),
          new THREE.MeshNormalMaterial({
            side: THREE.DoubleSide,
            visible: true,
          })
        );
        plane.material.visible = false;
        scene.add(plane);

        bloom = new Bloom(5);

        var fxaaShader = new THREE.RawShaderMaterial({
          uniforms: {
            inputTexture: { type: "t", value: bloom.fbo.texture },
            resolution: { type: "v2", value: resolution },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("fxaa-fs").textContent,
        });

        fxaaTexture = new ShaderTexture(
          renderer,
          fxaaShader,
          1,
          1,
          null,
          null,
          THREE.NearestFilter,
          null,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping
        );
        fxaaTexture.fbo.generateMipMaps = false;

        var finalShader = new THREE.RawShaderMaterial({
          uniforms: {
            inputTexture: { type: "t", value: baseFBO.texture },
            resolution: { type: "v2", value: resolution },
            boost: { type: "f", value: 1.1 },
            reduction: { type: "f", value: 1.1 },
            amount: { type: "f", value: 0.1 },
            time: { type: "f", value: 0 },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("final-fs").textContent,
        });

        finalTexture = new ShaderTexture(
          renderer,
          finalShader,
          1,
          1,
          null,
          null,
          THREE.NearestFilter,
          null,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping
        );
        finalTexture.fbo.generateMipMaps = false;
      }

      var params = {
        animate: true,
        friction: 0.7,
        scatter: 1,
        spread: 0.1,
        size: 1,
      };

      var gui = new dat.GUI();
      gui.add(params, "spread", 0.01, 1, 0.1).onChange((v) => {
        positionSim.shader.uniforms.spread.value = v;
      });
      gui.add(params, "friction", 0.01, 2, 0.1).onChange((v) => {
        velocitySim.shader.uniforms.friction.value = v;
      });
      gui.add(params, "scatter", 0.01, 10, 0.1).onChange((v) => {
        velocitySim.shader.uniforms.scatter.value = v;
      });
      gui.add(params, "size", 0.01, 10, 0.1).onChange((v) => {
        mesh.material.uniforms.size.value = v;
      });

      function init() {
        container = document.getElementById("container");

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.target = new THREE.Vector3(0, 0, 0);
        camera.position.set(100, 100, 100);
        camera.lookAt(camera.target);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0, 0);
        container.appendChild(renderer.domElement);

        helper = new FBOHelper(renderer);
        helper.show(false);

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        initScene();
        onWindowResized();

        window.addEventListener("resize", onWindowResized);

        window.addEventListener("keydown", function (e) {
          if (e.keyCode === 32) {
            params.animate = !params.animate;
          }
        });

        window.addEventListener("mousemove", function (e) {
          mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
        });

        renderer.domElement.addEventListener("touchmove", function (e) {
          mouse.x =
            (e.touches[0].clientX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y =
            -(e.touches[0].clientY / renderer.domElement.clientHeight) * 2 + 1;
        });

        animate();
      }

      function onWindowResized(event) {
        var w = container.clientWidth;
        var h = container.clientHeight;

        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        mesh.material.uniforms.resolution.value.set(w, h);

        var dPR = 0.5 * window.devicePixelRatio;
        bloom.setSize(w * dPR, h * dPR);
        resolution.set(w * dPR, h * dPR);
        baseFBO.setSize(w * dPR, h * dPR);
        finalTexture.setSize(w * dPR, h * dPR);
        fxaaTexture.setSize(w * dPR, h * dPR);
        helper.refreshFBO(baseFBO);

        helper.setSize(w, h);
      }

      var nOffset = new THREE.Vector3();
      var tmpVector = new THREE.Vector3();
      var tmpMatrix = new THREE.Matrix4();

      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        renderer.setClearColor(0xffffff, 1);

        if (params.animate) {
          raycaster.setFromCamera(mouse, camera);

          var intersects = raycaster.intersectObjects(objects.all);

          if (intersects.length) {
            pointerDummy.position.copy(intersects[0].point);
            shadowCamera.position.set(0, 200, 0);
            lightDummy.position.copy(shadowCamera.position);
            shadowCamera.lookAt(intersects[0].point);
            lightDummy.lookAt(intersects[0].point);
            objMaterial.uniforms.lightDir.value
              .set(0, 0, 1)
              .applyMatrix4(shadowCamera.matrix);
            positionSim.shader.uniforms.spawnSource.value.set(
              intersects[0].point.x,
              150,
              intersects[0].point.z
            );
            positionSim.shader.uniforms.spawnSource.value.set(0, 150, 0);
            tmpVector
              .copy(positionSim.shader.uniforms.spawnSource.value)
              .sub(intersects[0].point);
            var steps = tmpVector.y / 0.98;
            var l = tmpVector.length();
            tmpVector.normalize();
            tmpVector.multiplyScalar(-l / steps);
            tmpVector.y = 0;
            velocitySim.shader.uniforms.spawnVelocity.value.copy(tmpVector);
          }

          //velocitySim.shader.uniforms.spawnVelocity.value.set(0,-1,0);
          velocitySim.shader.uniforms.positions.value = positionSim.front;
          velocitySim.render();
          positionSim.shader.uniforms.velocities.value = velocitySim.front;
          positionSim.render();
          mesh.material.uniforms.positions.value = positionSim.front;
          mesh.material.uniforms.velocities.value = velocitySim.front;

          positionSim.shader.uniforms.reset.value = 0;
          velocitySim.shader.uniforms.reset.value = 0;
        }

        mesh.visible = false;
        //mesh.material.uniforms.shadow.value = true;
        //mesh.material.uniforms.depthTexture.value = null;
        //objMaterial.side = THREE.BackSide;
        objMaterial.uniforms.shadow.value = true;
        objMaterial.uniforms.depthTexture.value = null;
        renderer.render(scene, shadowCamera, shadowBuffer);

        mesh.visible = true;
        //objMaterial.side = THREE.FrontSide;
        objMaterial.uniforms.shadow.value = false;
        mesh.material.uniforms.shadow.value = false;

        mesh.material.uniforms.depthTexture.value = shadowBuffer.texture;
        mesh.material.uniforms.shadowP.value.copy(
          shadowCamera.projectionMatrix
        );
        mesh.material.uniforms.shadowV.value.copy(
          shadowCamera.matrixWorldInverse
        );

        objMaterial.uniforms.depthTexture.value = shadowBuffer.texture;
        objMaterial.uniforms.shadowP.value.copy(shadowCamera.projectionMatrix);
        objMaterial.uniforms.shadowV.value.copy(
          shadowCamera.matrixWorldInverse
        );

        renderer.setClearColor(0x202020, 1);
        renderer.render(scene, camera, baseFBO);
        bloom.render();
        fxaaTexture.render();
        finalTexture.shader.uniforms.inputTexture.value =
          fxaaTexture.fbo.texture;
        finalTexture.shader.uniforms.time.value = 0.0001 * performance.now();
        finalTexture.render(true);

        helper.update();
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>
